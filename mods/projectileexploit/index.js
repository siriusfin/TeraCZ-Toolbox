module.exports = function Memeslash(dispatch) {
  const command = dispatch.command;

  let enabled = true;
  let cid = null;
  let projectiles = [];
  let timer = null;
  let curProjectile = 0;

  let timerIterations = 6; //5 in alliance
  let timerTick = 1;

  let auto = false;
  let targets = [];

  let boss = null;
  let autoboss = true;

  let debugIds = false;
  let hideHits = true;

  let currentPosition = { x: 0, y: 0, z: 0, w: 0 };

  let templateIds = new Set();

  let NPC_MAP = new Map();

  let shiftpos = 0;
  let curX = 0;
  let curY = 0;
  let curZ = 0;

  command.add('memeslash', () => {
    enabled = !enabled;
    command.message(`Memeslash is now ${enabled ? "enabled" : "disabled"}.`);
  });

  command.add('automeme', () => {
    auto = !auto;
    command.message(`Auto memeslash is now ${auto ? "enabled" : "disabled"}.`);
  });

  command.add('nagas', () => {
    autoboss = false;
    auto = true;
    templateIds.add(4000);
    timerIterations = 10;
    dispatch.command.exec('dg nagas');
  });

  command.add('addtarget', (id) => {
    let temp = Number(id); //4000 naga //34 = watermelon
    templateIds.add(temp);
    command.message('Target added.');
  });

  command.add('cleartargets', () => {
    templateIds.clear();
  });

  command.add('autoboss', () => {
    autoboss = !autoboss;
    command.message(`Auto memeslash boss is now ${autoboss ? "enabled" : "disabled"}.`);
  });

  command.add('msdebug', () => {
    debugIds = !debugIds;
    command.message(`Debugging mob template ids: ${autoboss ? "on" : "off"}.`);
  })

  command.add('inv', () => {
    if (shiftpos == 0) {
      command.message("Invicible On");
      shiftpos = -600;
    } else {
      command.message("Invicible Off");
      shiftpos = 0;
    }
  });

  command.add('memeslash.interval', (iter, tick) => {
    iter = parseInt(iter);
    tick = parseInt(tick);
    if (iter && tick) {
      command.message(`Now repeating every ${tick} ms, ${iter} times`);
      timerIterations = iter;
      timerTick = tick;
    }
  });

  command.add('shiftpos', (offset) => {
    shiftpos = parseFloat(offset);
    command.message('ShiftPos ' + (shiftpos) + '.');
  });
  
  command.add('hidehits', () => {
    hideHits = !hideHits
    command.message('Hiding damage hits ' + (hideHits ? 'enabled' : 'disabled') + '.')
  })

  dispatch.hook('S_EACH_SKILL_RESULT', 'raw', () => {
    if (!hideHits) return
    return false
  })

  dispatch.hook('S_LOGIN', 2, event => {
    cid = event.cid;
    targets = [];
    NPC_MAP.clear();
  });

  dispatch.hook('S_SPAWN_NPC', 2, event => {
    if (debugIds)
      command.message('DEBUG: ' + event.templateId);
    NPC_MAP.set(event.gameId, event.templateId);
    targets.push(event.gameId);
  });

  dispatch.hook('S_DESPAWN_NPC', 1, event => {
    NPC_MAP.delete(event.target);
    for (let i = 0; i < targets.length; i++) {
      if (targets[i] == event.target) {
        targets.splice(i, 1);
        i--;
      }
    }
  });

  dispatch.hook('S_BOSS_GAGE_INFO', 2, event => {
    if(event.templateId != 202)
      boss = event.id;
  });

  dispatch.hook('S_LOAD_TOPO', 2, event => {
    targets = [];
  });

  dispatch.hook('S_START_USER_PROJECTILE', 1, event => {
    if (!enabled) return;

    if (cid && event.source == cid) {
      let packet = {
        source: event.id,
        end: false,
        x: event.x1,
        y: event.y1,
        z: event.z1,
        targets: []
      };

      if (auto) {
        targets.forEach(target => {
          if (templateIds.size > 0 && !templateIds.has(NPC_MAP.get(target)))
            return;
          packet.targets.push({ target, unk: 0 });
        });
      }

      if (boss && autoboss) {
        for (let i = 0;i < 2;i++)
          packet.targets.push({ target: boss, unk: 0 });
      }

      projectiles.push(packet);

      if (!timer) {
        timer = setInterval(resendPackets, timerTick);
      }
    }
  });

  dispatch.hook('S_END_USER_PROJECTILE', 1, event => {
    if (!enabled) return;
    clearProjectile(event.id);
  });

  dispatch.hook('C_HIT_USER_PROJECTILE', 1, event => {
    if (!enabled) return;
    
    for (let i = 0; i < projectiles.length; i++) {
      if (projectiles[i].source == event.source) {
        if (!event.end && event.targets.length > 0) {
          for (let target of event.targets) {
            projectiles[i].targets.push(target);
          }
          return false;
        } else if (event.end) {
          clearProjectile(event.source);
          return;
        }
      }
    }
  });

  dispatch.hook('C_PLAYER_LOCATION', 1, (event) => {
    curX = event.x1;
    curY = event.y1;
    curZ = event.z1;
    if (shiftpos === 0) 
      return;
    event.z1 += shiftpos
    event.z2 += shiftpos
    return true
  })

  dispatch.hook('S_ACTION_STAGE', 1, (event) => {
    if (boss && event.gameId == boss) {
      currentPosition.x = event.x;
      currentPosition.y = event.y;
      currentPosition.z = event.z;
      currentPosition.w = event.w;
    }

    if (shiftpos === 0) return
    if (!event.gameId == cid) return
    event.loc.x = curX
    event.loc.y = curY
    event.loc.z = curZ
    return true
  })

  dispatch.hook('S_ACTION_END', 1, (event) => {
    if (shiftpos === 0) return
    if (!event.gameId == cid) return
    event.loc.x = curX
    event.loc.y = curY
    event.loc.z = curZ
    return true
  });

  function clearProjectile(projectileId) {
    for (let i = 0; i < projectiles.length; i++) {
      if (projectiles[i].source == projectileId) {
        projectiles.splice(i, 1)
        i--;
      }
    }

    if (projectiles.length === 0) {
      if (timer !== null) {
        clearInterval(timer);
        timer = null;
        curProjectile = 0;
      }
    }
  }

  function resendPackets() {
    if (projectiles.length > 0) {
      if (!projectiles[curProjectile]) {
        curProjectile = 0;
      }

      for (let i = 0; i < timerIterations; i++) {
        dispatch.toServer('C_HIT_USER_PROJECTILE', 1, projectiles[curProjectile]);
      }
      curProjectile = (curProjectile + 1) % projectiles.length;
    }
  }
}
